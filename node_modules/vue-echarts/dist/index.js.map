{"version":3,"file":"index.js","names":["root","chart","autoresize","ro: ResizeObserver | null","LOADING_OPTIONS_KEY: InjectionKey<LoadingOptionsInjection>","result: Attrs","warn","cur: Record<string, unknown> | undefined","slotNames: SlotName[]","registered: boolean | null","arrays: Record<string, ArraySummary | undefined>","objects: string[]","scalars: string[]","missing: string[]","cssRules","THEME_KEY: InjectionKey<ThemeInjection>","INIT_OPTIONS_KEY: InjectionKey<InitOptionsInjection>","UPDATE_OPTIONS_KEY: InjectionKey<UpdateOptionsInjection>","nativeListeners: Record<string, unknown>","listeners: Map<{ event: string; once?: boolean; zr?: boolean }, any>","lastSignature: Signature | undefined","result: UpdateOptions","updateOptions","zr: boolean | undefined","once: boolean | undefined","init","initChart","setOption: SetOptionType","ECharts"],"sources":["../src/composables/api.ts","../src/composables/autoresize.ts","../src/composables/loading.ts","../src/utils.ts","../src/composables/slot.ts","../src/wc.ts","../src/update.ts","../src/style.css?raw","../src/style.ts","../src/ECharts.ts","../src/index.ts"],"sourcesContent":["import type { Ref } from \"vue\";\nimport type { EChartsType } from \"../types\";\n\nconst METHOD_NAMES = [\n  \"getWidth\",\n  \"getHeight\",\n  \"getDom\",\n  \"getOption\",\n  \"resize\",\n  \"dispatchAction\",\n  \"convertToPixel\",\n  \"convertFromPixel\",\n  \"containPixel\",\n  \"getDataURL\",\n  \"getConnectedDataURL\",\n  \"appendData\",\n  \"clear\",\n  \"isDisposed\",\n  \"dispose\",\n] as const;\n\ntype MethodName = (typeof METHOD_NAMES)[number];\n\nexport type PublicMethods = Pick<EChartsType, MethodName>;\n\nexport function usePublicAPI(\n  chart: Ref<EChartsType | undefined>,\n): PublicMethods {\n  function makePublicMethod<T extends MethodName>(name: T): EChartsType[T] {\n    // Return a function that matches the signature of EChartsType[T]\n    const fn = function (this: unknown, ...args: unknown[]): unknown {\n      if (!chart.value) {\n        throw new Error(\"ECharts is not initialized yet.\");\n      }\n      // Use Reflect.apply to call the method with proper context\n      return Reflect.apply(chart.value[name], chart.value, args);\n    };\n    return fn as EChartsType[T];\n  }\n\n  // Build the methods object with proper typing\n  const methods = METHOD_NAMES.reduce(\n    (acc, name) => {\n      acc[name] = makePublicMethod(name);\n      return acc;\n    },\n    {} as Record<MethodName, unknown>,\n  ) as PublicMethods;\n\n  return methods;\n}\n","import { watch } from \"vue\";\nimport { throttle } from \"echarts/core\";\n\nimport type { Ref, PropType } from \"vue\";\nimport type { EChartsType, AutoResize } from \"../types\";\n\nexport function useAutoresize(\n  chart: Ref<EChartsType | undefined>,\n  autoresize: Ref<AutoResize | undefined>,\n  root: Ref<HTMLElement | undefined>,\n): void {\n  watch(\n    [root, chart, autoresize],\n    ([root, chart, autoresize], _, onCleanup) => {\n      let ro: ResizeObserver | null = null;\n\n      if (root && chart && autoresize) {\n        const { offsetWidth, offsetHeight } = root;\n        const autoresizeOptions = autoresize === true ? {} : autoresize;\n        const { throttle: wait = 100, onResize } = autoresizeOptions;\n\n        let initialResizeTriggered = false;\n\n        const callback = () => {\n          chart.resize();\n          onResize?.();\n        };\n\n        const resizeCallback = wait ? throttle(callback, wait) : callback;\n\n        ro = new ResizeObserver(() => {\n          // We just skip ResizeObserver's initial resize callback if the\n          // size has not changed since the chart is rendered.\n          if (!initialResizeTriggered) {\n            initialResizeTriggered = true;\n            if (\n              root.offsetWidth === offsetWidth &&\n              root.offsetHeight === offsetHeight\n            ) {\n              return;\n            }\n          }\n\n          // Skip if container has zero size\n          if (root.offsetWidth === 0 || root.offsetHeight === 0) {\n            return;\n          }\n\n          resizeCallback();\n        });\n        ro.observe(root);\n      }\n\n      onCleanup(() => {\n        if (ro) {\n          ro.disconnect();\n          ro = null;\n        }\n      });\n    },\n  );\n}\n\nexport const autoresizeProps = {\n  autoresize: [Boolean, Object] as PropType<AutoResize>,\n};\n","import { inject, computed, watchEffect, toValue } from \"vue\";\n\nimport type { Ref, InjectionKey, PropType } from \"vue\";\nimport type {\n  EChartsType,\n  LoadingOptions,\n  LoadingOptionsInjection,\n} from \"../types\";\n\nexport const LOADING_OPTIONS_KEY: InjectionKey<LoadingOptionsInjection> =\n  Symbol();\n\nexport function useLoading(\n  chart: Ref<EChartsType | undefined>,\n  loading: Ref<boolean | undefined>,\n  loadingOptions: Ref<LoadingOptions | undefined>,\n): void {\n  const defaultLoadingOptions = inject(LOADING_OPTIONS_KEY, {});\n  const realLoadingOptions = computed(() => ({\n    ...toValue(defaultLoadingOptions),\n    ...loadingOptions?.value,\n  }));\n\n  watchEffect(() => {\n    const instance = chart.value;\n    if (!instance) {\n      return;\n    }\n\n    if (loading.value) {\n      instance.showLoading(realLoadingOptions.value);\n    } else {\n      instance.hideLoading();\n    }\n  });\n}\n\nexport const loadingProps = {\n  loading: Boolean,\n  loadingOptions: Object as PropType<LoadingOptions>,\n};\n","import { warn as vueWarn } from \"vue\";\n\ntype Attrs = Record<string, any>;\n\nexport function isBrowser(): boolean {\n  return typeof window !== \"undefined\" && typeof document !== \"undefined\";\n}\n\n// Copied from\n// https://github.com/vuejs/vue-next/blob/5a7a1b8293822219283d6e267496bec02234b0bc/packages/shared/src/index.ts#L40-L41\nconst onRE = /^on[^a-z]/;\nexport const isOn = (key: string): boolean => onRE.test(key);\n\nexport function omitOn(attrs: Attrs): Attrs {\n  const result: Attrs = {};\n  for (const key in attrs) {\n    if (!isOn(key)) {\n      result[key] = attrs[key];\n    }\n  }\n\n  return result;\n}\n\nexport function isValidArrayIndex(key: string): boolean {\n  const num = Number(key);\n  return (\n    Number.isInteger(num) &&\n    num >= 0 &&\n    num < Math.pow(2, 32) - 1 &&\n    String(num) === key\n  );\n}\n\nexport function isSameSet<T>(a: T[], b: T[]): boolean {\n  const setA = new Set(a);\n  const setB = new Set(b);\n\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (const val of setA) {\n    if (!setB.has(val)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isPlainObject(v: unknown): v is Record<string, unknown> {\n  return v != null && typeof v === \"object\" && !Array.isArray(v);\n}\n\nconst LOG_PREFIX = \"[vue-echarts]\";\n\nexport function warn(message: string): void {\n  vueWarn(`${LOG_PREFIX} ${message}`);\n}\n","import {\n  h,\n  Teleport,\n  onUpdated,\n  onUnmounted,\n  onMounted,\n  shallowRef,\n  shallowReactive,\n} from \"vue\";\nimport type { Slots, SlotsType } from \"vue\";\nimport type { Option } from \"../types\";\nimport { isBrowser, isValidArrayIndex, isSameSet, warn } from \"../utils\";\nimport type { TooltipComponentFormatterCallbackParams } from \"echarts\";\n\nconst SLOT_OPTION_PATHS = {\n  tooltip: [\"tooltip\", \"formatter\"],\n  dataView: [\"toolbox\", \"feature\", \"dataView\", \"optionToContent\"],\n} as const;\ntype SlotPrefix = keyof typeof SLOT_OPTION_PATHS;\ntype SlotName = SlotPrefix | `${SlotPrefix}-${string}`;\ntype SlotRecord<T> = Partial<Record<SlotName, T>>;\nconst SLOT_PREFIXES = Object.keys(SLOT_OPTION_PATHS) as SlotPrefix[];\n\nfunction isValidSlotName(key: string): key is SlotName {\n  return SLOT_PREFIXES.some(\n    (slotPrefix) => key === slotPrefix || key.startsWith(slotPrefix + \"-\"),\n  );\n}\n\nexport function useSlotOption(slots: Slots, onSlotsChange: () => void) {\n  const detachedRoot = isBrowser() ? document.createElement(\"div\") : undefined;\n  const containers = shallowReactive<SlotRecord<HTMLElement>>({});\n  const initialized = shallowReactive<SlotRecord<boolean>>({});\n  const params = shallowReactive<SlotRecord<unknown>>({});\n  const isMounted = shallowRef(false);\n\n  // Teleport the slots to a detached root\n  const teleportedSlots = () => {\n    // Make slots client-side only to avoid SSR hydration mismatch\n    return isMounted.value && detachedRoot\n      ? h(\n          Teleport,\n          { to: detachedRoot },\n          Object.entries(slots)\n            .filter(([key]) => isValidSlotName(key))\n            .map(([key, slot]) => {\n              const slotName = key as SlotName;\n              const slotContent = initialized[slotName]\n                ? slot?.(params[slotName])\n                : undefined;\n              return h(\n                \"div\",\n                {\n                  ref: (el) => {\n                    if (el instanceof HTMLElement) {\n                      containers[slotName] = el;\n                    }\n                  },\n                  style: { display: \"contents\" },\n                },\n                slotContent,\n              );\n            }),\n        )\n      : undefined;\n  };\n\n  // Helper to check if a value is a plain object\n  function isObject(val: unknown): val is Record<string, unknown> {\n    return val !== null && typeof val === \"object\" && !Array.isArray(val);\n  }\n\n  // Shallow-clone the option along each path and override the target callback\n  function patchOption(src: Option): Option {\n    const root = { ...src } as Record<string, unknown>;\n\n    // Ensure the child at `seg` is a writable container (cloned or newly created).\n    // Returns the child container, or undefined if traversal is blocked by a primitive.\n    const ensureChild = (\n      parent: Record<string, unknown>,\n      seg: string,\n    ): Record<string, unknown> | undefined => {\n      const next = parent[seg];\n\n      if (Array.isArray(next)) {\n        parent[seg] = [...next];\n        return parent[seg] as Record<string, unknown>;\n      }\n      if (isObject(next)) {\n        parent[seg] = { ...next };\n        return parent[seg] as Record<string, unknown>;\n      }\n      if (next === undefined) {\n        parent[seg] = isValidArrayIndex(seg) ? [] : {};\n        return parent[seg] as Record<string, unknown>;\n      }\n      // Blocked by a non-container value\n      return undefined;\n    };\n\n    Object.keys(slots)\n      .filter((key) => {\n        const valid = isValidSlotName(key);\n        if (!valid) {\n          warn(`Invalid slot name: ${key}`);\n        }\n        return valid;\n      })\n      .forEach((key) => {\n        const [prefix, ...rest] = key.split(\"-\") as [SlotPrefix, ...string[]];\n        const tail = SLOT_OPTION_PATHS[prefix];\n        if (!tail) {\n          return;\n        }\n\n        const path = [...rest, ...tail];\n        if (path.length === 0) {\n          return;\n        }\n\n        // Traverse to the parent of the leaf, cloning or creating along the way\n        let cur: Record<string, unknown> | undefined = root;\n        for (let i = 0; i < path.length - 1; i++) {\n          cur = ensureChild(cur, path[i]);\n          if (!cur) {\n            return; // Blocked by a primitive â€” skip this key\n          }\n        }\n\n        cur[path[path.length - 1]] = (p: unknown) => {\n          initialized[key] = true;\n          params[key] = p;\n          return containers[key];\n        };\n      });\n\n    return root as Option;\n  }\n\n  // `slots` is not reactive, so we need to watch it manually\n  let slotNames: SlotName[] = [];\n  onUpdated(() => {\n    const newSlotNames = Object.keys(slots).filter(isValidSlotName);\n    if (!isSameSet(newSlotNames, slotNames)) {\n      // Clean up states for removed slots\n      slotNames.forEach((key) => {\n        if (!newSlotNames.includes(key)) {\n          delete params[key];\n          delete initialized[key];\n          delete containers[key];\n        }\n      });\n      slotNames = newSlotNames;\n      onSlotsChange();\n    }\n  });\n\n  onMounted(() => {\n    isMounted.value = true;\n  });\n\n  onUnmounted(() => {\n    detachedRoot?.remove();\n  });\n\n  return {\n    teleportedSlots,\n    patchOption,\n  };\n}\n\nexport type SlotsTypes = SlotsType<\n  Record<\n    \"tooltip\" | `tooltip-${string}`,\n    TooltipComponentFormatterCallbackParams\n  > &\n    Record<\"dataView\" | `dataView-${string}`, Option>\n>;\n","import { isBrowser } from \"./utils\";\n\nlet registered: boolean | null = null;\n\nexport const TAG_NAME = \"x-vue-echarts\";\n\nexport interface EChartsElement extends HTMLElement {\n  __dispose: (() => void) | null;\n}\n\nexport function register(): boolean {\n  if (registered != null) {\n    return registered;\n  }\n\n  const registry = globalThis.customElements;\n\n  if (!isBrowser() || !registry?.get) {\n    registered = false;\n    return registered;\n  }\n\n  if (!registry.get(TAG_NAME)) {\n    try {\n      class ECElement extends HTMLElement implements EChartsElement {\n        __dispose: (() => void) | null = null;\n\n        disconnectedCallback(): void {\n          if (this.__dispose) {\n            this.__dispose();\n            this.__dispose = null;\n          }\n        }\n      }\n\n      registry.define(TAG_NAME, ECElement);\n    } catch {\n      registered = false;\n      return registered;\n    }\n  }\n\n  registered = true;\n  return registered;\n}\n","import type { Option } from \"./types\";\nimport { isPlainObject } from \"./utils\";\n\nexport interface UpdatePlan {\n  notMerge: boolean;\n  replaceMerge?: string[];\n}\n\n/** Summary of a top-level array key for deletion detection. */\nexport interface ArraySummary {\n  /** Unique, sorted string ids extracted from items' `id` field. */\n  idsSorted: string[];\n  /** Count of items without an `id` field. */\n  noIdCount: number;\n}\n\n/** Minimal signature of an option used to decide setOption behavior. */\nexport interface Signature {\n  /** Lengths of `option.options` and `option.media` (0 if not arrays). */\n  optionsLength: number;\n  mediaLength: number;\n  /** Map of array-typed top-level keys to their summaries. */\n  arrays: Record<string, ArraySummary | undefined>;\n  /** Sorted list of object-typed top-level keys. */\n  objects: string[];\n  /** Sorted list of scalar-typed top-level keys (string|number|boolean|null). */\n  scalars: string[];\n}\n\n/**\n * Read an item's `id` as a string.\n * Only accept string or number. Other types are ignored to surface inconsistent data early.\n */\nfunction readId(item: unknown): string | undefined {\n  if (!isPlainObject(item)) {\n    return undefined;\n  }\n  const raw = (item as { id?: unknown }).id;\n  if (typeof raw === \"string\") {\n    return raw;\n  }\n  if (typeof raw === \"number\" && Number.isFinite(raw)) {\n    return String(raw);\n  }\n  return undefined;\n}\n\n/**\n * Build a minimal signature from a full ECharts option.\n * Only top-level keys are inspected.\n */\nexport function buildSignature(option: Option): Signature {\n  const opt = option as Record<string, unknown>;\n\n  const optionsLength = Array.isArray(opt.options)\n    ? (opt.options as unknown[]).length\n    : 0;\n  const mediaLength = Array.isArray(opt.media)\n    ? (opt.media as unknown[]).length\n    : 0;\n\n  const arrays: Record<string, ArraySummary | undefined> = Object.create(null);\n  const objects: string[] = [];\n  const scalars: string[] = [];\n\n  for (const key of Object.keys(opt)) {\n    if (key === \"options\" || key === \"media\") {\n      continue;\n    }\n\n    const value = opt[key];\n\n    if (Array.isArray(value)) {\n      const items = value as unknown[];\n      const ids = new Set<string>();\n      let noIdCount = 0;\n\n      for (let i = 0; i < items.length; i++) {\n        const id = readId(items[i]);\n        if (id !== undefined) {\n          ids.add(id);\n        } else {\n          noIdCount++;\n        }\n      }\n\n      const idsSorted = ids.size > 0 ? Array.from(ids).sort() : [];\n\n      arrays[key] = { idsSorted, noIdCount };\n    } else if (isPlainObject(value)) {\n      objects.push(key);\n    } else {\n      // scalar: string | number | boolean | null  (undefined is treated as \"absent\")\n      if (value !== undefined) {\n        scalars.push(key);\n      }\n    }\n  }\n\n  if (objects.length > 1) {\n    objects.sort();\n  }\n  if (scalars.length > 1) {\n    scalars.sort();\n  }\n\n  return { optionsLength, mediaLength, arrays, objects, scalars };\n}\n\nfunction diffKeys(\n  prevKeys: readonly string[],\n  nextKeys: readonly string[],\n): string[] {\n  if (prevKeys.length === 0) {\n    return [];\n  }\n  if (nextKeys.length === 0) {\n    return prevKeys.slice();\n  }\n\n  const nextSet = new Set(nextKeys);\n  const missing: string[] = [];\n\n  for (let i = 0; i < prevKeys.length; i++) {\n    const key = prevKeys[i];\n    if (!nextSet.has(key)) {\n      missing.push(key);\n    }\n  }\n\n  return missing;\n}\n\nfunction hasMissingIds(\n  prevIds: readonly string[],\n  nextIds: readonly string[],\n): boolean {\n  if (prevIds.length === 0) {\n    return false;\n  }\n  if (nextIds.length === 0) {\n    return true;\n  }\n\n  const nextSet = new Set(nextIds);\n  for (let i = 0; i < prevIds.length; i++) {\n    if (!nextSet.has(prevIds[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface PlannedUpdate {\n  option: Option;\n  signature: Signature;\n  plan: UpdatePlan;\n}\n\n/**\n * Produce an update plan plus a normalized option that encodes common deletions.\n * Falls back to `notMerge: true` when the change looks complex.\n */\nexport function planUpdate(\n  prev: Signature | undefined,\n  option: Option,\n): PlannedUpdate {\n  const next = buildSignature(option);\n\n  if (!prev) {\n    return { option, signature: next, plan: { notMerge: false } };\n  }\n\n  if (next.optionsLength < prev.optionsLength) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n  if (next.mediaLength < prev.mediaLength) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n\n  if (diffKeys(prev.scalars, next.scalars).length > 0) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n\n  const replace = new Set<string>();\n  const overrides = new Map<string, null | []>();\n\n  const missingObjects = diffKeys(prev.objects, next.objects);\n  for (let i = 0; i < missingObjects.length; i++) {\n    overrides.set(missingObjects[i], null);\n  }\n\n  for (const key of Object.keys(prev.arrays)) {\n    const prevArray = prev.arrays[key];\n    if (!prevArray) {\n      continue;\n    }\n\n    const nextArray = next.arrays[key];\n\n    if (!nextArray) {\n      if (prevArray.idsSorted.length > 0 || prevArray.noIdCount > 0) {\n        overrides.set(key, []);\n        replace.add(key);\n      }\n      continue;\n    }\n\n    if (hasMissingIds(prevArray.idsSorted, nextArray.idsSorted)) {\n      replace.add(key);\n      continue;\n    }\n\n    if (nextArray.noIdCount < prevArray.noIdCount) {\n      replace.add(key);\n    }\n  }\n\n  let normalizedOption = option;\n  let signature = next;\n\n  if (overrides.size > 0) {\n    const clone = { ...(option as Record<string, unknown>) };\n    overrides.forEach((value, key) => {\n      clone[key] = value;\n    });\n    normalizedOption = clone as Option;\n    signature = buildSignature(normalizedOption);\n  }\n\n  const replaceMerge =\n    replace.size > 0 ? Array.from(replace).sort() : undefined;\n\n  const plan = replaceMerge\n    ? { notMerge: false, replaceMerge }\n    : { notMerge: false };\n\n  return {\n    option: normalizedOption,\n    signature,\n    plan,\n  };\n}\n","export default \"x-vue-echarts{display:block;width:100%;height:100%;min-width:0;}\\nx-vue-echarts>:first-child,x-vue-echarts>:first-child>canvas{border-radius:inherit;}\\n\"","import cssRules from \"./style.css?raw\";\n\nif (typeof document !== \"undefined\") {\n  if (\n    Array.isArray(document.adoptedStyleSheets) &&\n    \"replaceSync\" in CSSStyleSheet.prototype\n  ) {\n    const sheet = new CSSStyleSheet();\n    sheet.replaceSync(cssRules);\n    document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];\n  } else {\n    const styleEl = document.createElement(\"style\");\n    styleEl.textContent = cssRules;\n    document.head.appendChild(styleEl);\n  }\n}\n","import {\n  defineComponent,\n  shallowRef,\n  toRefs,\n  watch,\n  computed,\n  inject,\n  onMounted,\n  onBeforeUnmount,\n  h,\n  nextTick,\n  watchEffect,\n  toValue,\n} from \"vue\";\nimport { init as initChart } from \"echarts/core\";\nimport type { EChartsOption } from \"echarts\";\n\nimport {\n  usePublicAPI,\n  useAutoresize,\n  autoresizeProps,\n  useLoading,\n  loadingProps,\n  useSlotOption,\n} from \"./composables\";\nimport type { PublicMethods, SlotsTypes } from \"./composables\";\nimport { isOn, omitOn, warn } from \"./utils\";\nimport { register, TAG_NAME } from \"./wc\";\nimport { planUpdate } from \"./update\";\nimport type { Signature, UpdatePlan } from \"./update\";\n\nimport type { PropType, InjectionKey } from \"vue\";\nimport type {\n  EChartsType,\n  SetOptionType,\n  Option,\n  Theme,\n  ThemeInjection,\n  InitOptions,\n  InitOptionsInjection,\n  UpdateOptions,\n  UpdateOptionsInjection,\n  Emits,\n} from \"./types\";\nimport type { EChartsElement } from \"./wc\";\n\nimport \"./style.ts\";\n\nconst wcRegistered = register();\n\nexport const THEME_KEY: InjectionKey<ThemeInjection> = Symbol();\nexport const INIT_OPTIONS_KEY: InjectionKey<InitOptionsInjection> = Symbol();\nexport const UPDATE_OPTIONS_KEY: InjectionKey<UpdateOptionsInjection> =\n  Symbol();\nexport { LOADING_OPTIONS_KEY } from \"./composables\";\n\nexport default defineComponent({\n  name: \"Echarts\",\n  inheritAttrs: false,\n  props: {\n    option: Object as PropType<Option>,\n    theme: {\n      type: [Object, String] as PropType<Theme>,\n    },\n    initOptions: Object as PropType<InitOptions>,\n    updateOptions: Object as PropType<UpdateOptions>,\n    group: String,\n    manualUpdate: Boolean,\n    ...autoresizeProps,\n    ...loadingProps,\n  },\n  emits: {} as unknown as Emits,\n  slots: Object as SlotsTypes,\n  setup(props, { attrs, expose, slots }) {\n    const root = shallowRef<EChartsElement>();\n    const chart = shallowRef<EChartsType>();\n    const defaultTheme = inject(THEME_KEY, null);\n    const defaultInitOptions = inject(INIT_OPTIONS_KEY, null);\n    const defaultUpdateOptions = inject(UPDATE_OPTIONS_KEY, null);\n\n    const { autoresize, manualUpdate, loading, loadingOptions } = toRefs(props);\n\n    const realTheme = computed(() => props.theme || toValue(defaultTheme));\n    const realInitOptions = computed(\n      () => props.initOptions || toValue(defaultInitOptions) || undefined,\n    );\n    const realUpdateOptions = computed(\n      () => props.updateOptions || toValue(defaultUpdateOptions),\n    );\n    const nonEventAttrs = computed(() => omitOn(attrs));\n    const nativeListeners: Record<string, unknown> = {};\n\n    const listeners: Map<{ event: string; once?: boolean; zr?: boolean }, any> =\n      new Map();\n\n    const { teleportedSlots, patchOption } = useSlotOption(slots, () => {\n      if (!manualUpdate.value && props.option && chart.value) {\n        applyOption(chart.value, props.option);\n      }\n    });\n\n    let lastSignature: Signature | undefined;\n\n    function resolveUpdateOptions(plan?: UpdatePlan): UpdateOptions {\n      const result: UpdateOptions = {};\n\n      const replacements = (plan?.replaceMerge ?? []).filter(\n        (key): key is string => key != null,\n      );\n      if (replacements.length > 0) {\n        result.replaceMerge = [...new Set(replacements)];\n      }\n\n      if (plan?.notMerge !== undefined) {\n        result.notMerge = plan.notMerge;\n      }\n\n      return result;\n    }\n\n    function applyOption(\n      instance: EChartsType,\n      option: Option,\n      override?: UpdateOptions,\n      manual = false,\n    ) {\n      const patched = patchOption(option);\n\n      if (manual) {\n        instance.setOption(patched, override ?? {});\n        lastSignature = undefined;\n        return;\n      }\n\n      if (realUpdateOptions.value) {\n        const updateOptions = override ?? realUpdateOptions.value;\n        instance.setOption(patched, updateOptions);\n        lastSignature = undefined;\n        return;\n      }\n\n      const planned = planUpdate(\n        lastSignature,\n        patched as unknown as EChartsOption,\n      );\n\n      const updateOptions = resolveUpdateOptions(planned.plan);\n      instance.setOption(planned.option, updateOptions);\n      lastSignature = planned.signature;\n    }\n\n    // We are converting all `on<Event>` props and collect them into `listeners` so that\n    // we can bind them to the chart instance later.\n    // For `onNative:<event>` props, we just strip the `Native:` part and collect them into\n    // `nativeListeners` so that we can bind them to the root element directly.\n    Object.keys(attrs)\n      .filter((key) => isOn(key))\n      .forEach((key) => {\n        // Collect native DOM events\n        if (key.indexOf(\"Native:\") === 2) {\n          // onNative:click -> onClick\n          const nativeKey = `on${key.charAt(9).toUpperCase()}${key.slice(10)}`;\n\n          nativeListeners[nativeKey] = attrs[key];\n          return;\n        }\n\n        // onClick    -> c + lick\n        // onZr:click -> z + r:click\n        let event = key.charAt(2).toLowerCase() + key.slice(3);\n\n        let zr: boolean | undefined;\n        if (event.indexOf(\"zr:\") === 0) {\n          zr = true;\n          event = event.substring(3);\n        }\n\n        let once: boolean | undefined;\n        if (event.substring(event.length - 4) === \"Once\") {\n          once = true;\n          event = event.substring(0, event.length - 4);\n        }\n\n        listeners.set({ event, zr, once }, attrs[key]);\n      });\n\n    function init() {\n      if (!root.value) {\n        return;\n      }\n\n      const instance = (chart.value = initChart(\n        root.value,\n        realTheme.value,\n        realInitOptions.value,\n      ));\n\n      if (props.group) {\n        instance.group = props.group;\n      }\n\n      listeners.forEach((handler, { zr, once, event }) => {\n        if (!handler) {\n          return;\n        }\n\n        const target = zr ? instance.getZr() : instance;\n\n        if (once) {\n          const raw = handler;\n          let called = false;\n\n          handler = (...args: any[]) => {\n            if (called) {\n              return;\n            }\n            called = true;\n            raw(...args);\n            target.off(event, handler);\n          };\n        }\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore EChartsType[\"on\"] is not compatible with ZRenderType[\"on\"]\n        // but it's okay here\n        target.on(event, handler);\n      });\n\n      function resize() {\n        if (instance && !instance.isDisposed()) {\n          instance.resize();\n        }\n      }\n\n      function commit() {\n        const { option } = props;\n\n        if (manualUpdate.value) {\n          if (option) {\n            applyOption(instance, option, undefined, true);\n          }\n          return;\n        }\n\n        if (option) {\n          applyOption(instance, option);\n        }\n      }\n\n      if (autoresize.value) {\n        // Try to make chart fit to container in case container size\n        // is changed synchronously or in already queued microtasks\n        nextTick(() => {\n          resize();\n          commit();\n        });\n      } else {\n        commit();\n      }\n    }\n    const setOption: SetOptionType = (\n      option,\n      notMerge,\n      lazyUpdate?: boolean,\n    ) => {\n      if (!props.manualUpdate) {\n        warn(\"`setOption` is only available when `manual-update` is `true`.\");\n        return;\n      }\n\n      const updateOptions =\n        typeof notMerge === \"boolean\" ? { notMerge, lazyUpdate } : notMerge;\n\n      if (!chart.value) {\n        return;\n      }\n\n      applyOption(chart.value, option, updateOptions ?? undefined, true);\n    };\n\n    function cleanup() {\n      if (chart.value) {\n        chart.value.dispose();\n        chart.value = undefined;\n      }\n      lastSignature = undefined;\n    }\n\n    watch(\n      () => props.option,\n      (option) => {\n        if (!option) {\n          lastSignature = undefined;\n          return;\n        }\n\n        if (manualUpdate.value) {\n          warn(\n            \"`option` prop changes are ignored when `manual-update` is `true`.\",\n          );\n          return;\n        }\n\n        if (!chart.value) {\n          return;\n        }\n\n        applyOption(chart.value, option);\n      },\n      { deep: true },\n    );\n\n    watch(\n      [manualUpdate, realInitOptions],\n      () => {\n        cleanup();\n        init();\n      },\n      {\n        deep: true,\n      },\n    );\n\n    watch(\n      realTheme,\n      (theme) => {\n        chart.value?.setTheme(theme || {});\n      },\n      {\n        deep: true,\n      },\n    );\n\n    watchEffect(() => {\n      if (props.group && chart.value) {\n        chart.value.group = props.group;\n      }\n    });\n\n    const publicApi = usePublicAPI(chart);\n\n    useLoading(chart, loading, loadingOptions);\n\n    useAutoresize(chart, autoresize, root);\n\n    onMounted(() => {\n      init();\n    });\n\n    onBeforeUnmount(() => {\n      if (wcRegistered && root.value) {\n        // For registered web component, we can leverage the\n        // `disconnectedCallback` to dispose the chart instance\n        // so that we can delay the cleanup after exsiting leaving\n        // transition.\n        root.value.__dispose = cleanup;\n      } else {\n        cleanup();\n      }\n    });\n\n    const exposed = {\n      setOption,\n      root,\n      chart,\n    };\n    expose({ ...exposed, ...publicApi });\n\n    // While `expose()` exposes methods and properties to the parent component\n    // via template refs at runtime, it doesn't contribute to TypeScript types.\n    // This type casting ensures TypeScript correctly types the exposed members\n    // that will be available when using this component.\n    return (() =>\n      h(\n        TAG_NAME,\n        {\n          ...nonEventAttrs.value,\n          ...nativeListeners,\n          ref: root,\n          class: [\"echarts\", nonEventAttrs.value.class],\n        },\n        teleportedSlots(),\n      )) as unknown as typeof exposed & PublicMethods;\n  },\n});\n","import ECharts from \"./ECharts\";\n\nexport default ECharts;\nexport * from \"./ECharts\";\n"],"mappings":";;;;AAGA,MAAM,eAAe;CACnB;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACD;AAMD,SAAgB,aACd,OACe;CACf,SAAS,iBAAuC,MAAyB;EAEvE,MAAM,KAAK,SAAyB,GAAG,MAA0B;AAC/D,OAAI,CAAC,MAAM,MACT,OAAM,IAAI,MAAM,kCAAkC;AAGpD,UAAO,QAAQ,MAAM,MAAM,MAAM,OAAO,MAAM,OAAO,KAAK;;AAE5D,SAAO;;AAYT,QARgB,aAAa,QAC1B,KAAK,SAAS;AACb,MAAI,QAAQ,iBAAiB,KAAK;AAClC,SAAO;IAET,EAAE,CACH;;;;;ACzCH,SAAgB,cACd,OACA,YACA,MACM;AACN,OACE;EAAC;EAAM;EAAO;EAAW,GACxB,CAACA,QAAMC,SAAOC,eAAa,GAAG,cAAc;EAC3C,IAAIC,KAA4B;AAEhC,MAAIH,UAAQC,WAASC,cAAY;GAC/B,MAAM,EAAE,aAAa,iBAAiBF;GAEtC,MAAM,EAAE,UAAU,OAAO,KAAK,aADJE,iBAAe,OAAO,EAAE,GAAGA;GAGrD,IAAI,yBAAyB;GAE7B,MAAM,iBAAiB;AACrB,YAAM,QAAQ;AACd,gBAAY;;GAGd,MAAM,iBAAiB,OAAO,SAAS,UAAU,KAAK,GAAG;AAEzD,QAAK,IAAI,qBAAqB;AAG5B,QAAI,CAAC,wBAAwB;AAC3B,8BAAyB;AACzB,SACEF,OAAK,gBAAgB,eACrBA,OAAK,iBAAiB,aAEtB;;AAKJ,QAAIA,OAAK,gBAAgB,KAAKA,OAAK,iBAAiB,EAClD;AAGF,oBAAgB;KAChB;AACF,MAAG,QAAQA,OAAK;;AAGlB,kBAAgB;AACd,OAAI,IAAI;AACN,OAAG,YAAY;AACf,SAAK;;IAEP;GAEL;;AAGH,MAAa,kBAAkB,EAC7B,YAAY,CAAC,SAAS,OAAO,EAC9B;;;;ACxDD,MAAaI,sBACX,QAAQ;AAEV,SAAgB,WACd,OACA,SACA,gBACM;CACN,MAAM,wBAAwB,OAAO,qBAAqB,EAAE,CAAC;CAC7D,MAAM,qBAAqB,gBAAgB;EACzC,GAAG,QAAQ,sBAAsB;EACjC,GAAG,gBAAgB;EACpB,EAAE;AAEH,mBAAkB;EAChB,MAAM,WAAW,MAAM;AACvB,MAAI,CAAC,SACH;AAGF,MAAI,QAAQ,MACV,UAAS,YAAY,mBAAmB,MAAM;MAE9C,UAAS,aAAa;GAExB;;AAGJ,MAAa,eAAe;CAC1B,SAAS;CACT,gBAAgB;CACjB;;;;ACpCD,SAAgB,YAAqB;AACnC,QAAO,OAAO,WAAW,eAAe,OAAO,aAAa;;AAK9D,MAAM,OAAO;AACb,MAAa,QAAQ,QAAyB,KAAK,KAAK,IAAI;AAE5D,SAAgB,OAAO,OAAqB;CAC1C,MAAMC,SAAgB,EAAE;AACxB,MAAK,MAAM,OAAO,MAChB,KAAI,CAAC,KAAK,IAAI,CACZ,QAAO,OAAO,MAAM;AAIxB,QAAO;;AAGT,SAAgB,kBAAkB,KAAsB;CACtD,MAAM,MAAM,OAAO,IAAI;AACvB,QACE,OAAO,UAAU,IAAI,IACrB,OAAO,KACP,MAAM,KAAK,IAAI,GAAG,GAAG,GAAG,KACxB,OAAO,IAAI,KAAK;;AAIpB,SAAgB,UAAa,GAAQ,GAAiB;CACpD,MAAM,OAAO,IAAI,IAAI,EAAE;CACvB,MAAM,OAAO,IAAI,IAAI,EAAE;AAEvB,KAAI,KAAK,SAAS,KAAK,KACrB,QAAO;AAGT,MAAK,MAAM,OAAO,KAChB,KAAI,CAAC,KAAK,IAAI,IAAI,CAChB,QAAO;AAIX,QAAO;;AAGT,SAAgB,cAAc,GAA0C;AACtE,QAAO,KAAK,QAAQ,OAAO,MAAM,YAAY,CAAC,MAAM,QAAQ,EAAE;;AAGhE,MAAM,aAAa;AAEnB,SAAgBC,OAAK,SAAuB;AAC1C,MAAQ,GAAG,WAAW,GAAG,UAAU;;;;;AC5CrC,MAAM,oBAAoB;CACxB,SAAS,CAAC,WAAW,YAAY;CACjC,UAAU;EAAC;EAAW;EAAW;EAAY;EAAkB;CAChE;AAID,MAAM,gBAAgB,OAAO,KAAK,kBAAkB;AAEpD,SAAS,gBAAgB,KAA8B;AACrD,QAAO,cAAc,MAClB,eAAe,QAAQ,cAAc,IAAI,WAAW,aAAa,IAAI,CACvE;;AAGH,SAAgB,cAAc,OAAc,eAA2B;CACrE,MAAM,eAAe,WAAW,GAAG,SAAS,cAAc,MAAM,GAAG;CACnE,MAAM,aAAa,gBAAyC,EAAE,CAAC;CAC/D,MAAM,cAAc,gBAAqC,EAAE,CAAC;CAC5D,MAAM,SAAS,gBAAqC,EAAE,CAAC;CACvD,MAAM,YAAY,WAAW,MAAM;CAGnC,MAAM,wBAAwB;AAE5B,SAAO,UAAU,SAAS,eACtB,EACE,UACA,EAAE,IAAI,cAAc,EACpB,OAAO,QAAQ,MAAM,CAClB,QAAQ,CAAC,SAAS,gBAAgB,IAAI,CAAC,CACvC,KAAK,CAAC,KAAK,UAAU;GACpB,MAAM,WAAW;AAIjB,UAAO,EACL,OACA;IACE,MAAM,OAAO;AACX,SAAI,cAAc,YAChB,YAAW,YAAY;;IAG3B,OAAO,EAAE,SAAS,YAAY;IAC/B,EAZiB,YAAY,YAC5B,OAAO,OAAO,UAAU,GACxB,OAYH;IACD,CACL,GACD;;CAIN,SAAS,SAAS,KAA8C;AAC9D,SAAO,QAAQ,QAAQ,OAAO,QAAQ,YAAY,CAAC,MAAM,QAAQ,IAAI;;CAIvE,SAAS,YAAY,KAAqB;EACxC,MAAM,OAAO,EAAE,GAAG,KAAK;EAIvB,MAAM,eACJ,QACA,QACwC;GACxC,MAAM,OAAO,OAAO;AAEpB,OAAI,MAAM,QAAQ,KAAK,EAAE;AACvB,WAAO,OAAO,CAAC,GAAG,KAAK;AACvB,WAAO,OAAO;;AAEhB,OAAI,SAAS,KAAK,EAAE;AAClB,WAAO,OAAO,EAAE,GAAG,MAAM;AACzB,WAAO,OAAO;;AAEhB,OAAI,SAAS,QAAW;AACtB,WAAO,OAAO,kBAAkB,IAAI,GAAG,EAAE,GAAG,EAAE;AAC9C,WAAO,OAAO;;;AAMlB,SAAO,KAAK,MAAM,CACf,QAAQ,QAAQ;GACf,MAAM,QAAQ,gBAAgB,IAAI;AAClC,OAAI,CAAC,MACH,QAAK,sBAAsB,MAAM;AAEnC,UAAO;IACP,CACD,SAAS,QAAQ;GAChB,MAAM,CAAC,QAAQ,GAAG,QAAQ,IAAI,MAAM,IAAI;GACxC,MAAM,OAAO,kBAAkB;AAC/B,OAAI,CAAC,KACH;GAGF,MAAM,OAAO,CAAC,GAAG,MAAM,GAAG,KAAK;AAC/B,OAAI,KAAK,WAAW,EAClB;GAIF,IAAIC,MAA2C;AAC/C,QAAK,IAAI,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACxC,UAAM,YAAY,KAAK,KAAK,GAAG;AAC/B,QAAI,CAAC,IACH;;AAIJ,OAAI,KAAK,KAAK,SAAS,OAAO,MAAe;AAC3C,gBAAY,OAAO;AACnB,WAAO,OAAO;AACd,WAAO,WAAW;;IAEpB;AAEJ,SAAO;;CAIT,IAAIC,YAAwB,EAAE;AAC9B,iBAAgB;EACd,MAAM,eAAe,OAAO,KAAK,MAAM,CAAC,OAAO,gBAAgB;AAC/D,MAAI,CAAC,UAAU,cAAc,UAAU,EAAE;AAEvC,aAAU,SAAS,QAAQ;AACzB,QAAI,CAAC,aAAa,SAAS,IAAI,EAAE;AAC/B,YAAO,OAAO;AACd,YAAO,YAAY;AACnB,YAAO,WAAW;;KAEpB;AACF,eAAY;AACZ,kBAAe;;GAEjB;AAEF,iBAAgB;AACd,YAAU,QAAQ;GAClB;AAEF,mBAAkB;AAChB,gBAAc,QAAQ;GACtB;AAEF,QAAO;EACL;EACA;EACD;;;;;ACtKH,IAAIC,aAA6B;AAEjC,MAAa,WAAW;AAMxB,SAAgB,WAAoB;AAClC,KAAI,cAAc,KAChB,QAAO;CAGT,MAAM,WAAW,WAAW;AAE5B,KAAI,CAAC,WAAW,IAAI,CAAC,UAAU,KAAK;AAClC,eAAa;AACb,SAAO;;AAGT,KAAI,CAAC,SAAS,IAAI,SAAS,CACzB,KAAI;EACF,MAAM,kBAAkB,YAAsC;GAC5D,YAAiC;GAEjC,uBAA6B;AAC3B,QAAI,KAAK,WAAW;AAClB,UAAK,WAAW;AAChB,UAAK,YAAY;;;;AAKvB,WAAS,OAAO,UAAU,UAAU;SAC9B;AACN,eAAa;AACb,SAAO;;AAIX,cAAa;AACb,QAAO;;;;;;;;;ACVT,SAAS,OAAO,MAAmC;AACjD,KAAI,CAAC,cAAc,KAAK,CACtB;CAEF,MAAM,MAAO,KAA0B;AACvC,KAAI,OAAO,QAAQ,SACjB,QAAO;AAET,KAAI,OAAO,QAAQ,YAAY,OAAO,SAAS,IAAI,CACjD,QAAO,OAAO,IAAI;;;;;;AAStB,SAAgB,eAAe,QAA2B;CACxD,MAAM,MAAM;CAEZ,MAAM,gBAAgB,MAAM,QAAQ,IAAI,QAAQ,GAC3C,IAAI,QAAsB,SAC3B;CACJ,MAAM,cAAc,MAAM,QAAQ,IAAI,MAAM,GACvC,IAAI,MAAoB,SACzB;CAEJ,MAAMC,SAAmD,OAAO,OAAO,KAAK;CAC5E,MAAMC,UAAoB,EAAE;CAC5B,MAAMC,UAAoB,EAAE;AAE5B,MAAK,MAAM,OAAO,OAAO,KAAK,IAAI,EAAE;AAClC,MAAI,QAAQ,aAAa,QAAQ,QAC/B;EAGF,MAAM,QAAQ,IAAI;AAElB,MAAI,MAAM,QAAQ,MAAM,EAAE;GACxB,MAAM,QAAQ;GACd,MAAM,sBAAM,IAAI,KAAa;GAC7B,IAAI,YAAY;AAEhB,QAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;IACrC,MAAM,KAAK,OAAO,MAAM,GAAG;AAC3B,QAAI,OAAO,OACT,KAAI,IAAI,GAAG;QAEX;;AAMJ,UAAO,OAAO;IAAE,WAFE,IAAI,OAAO,IAAI,MAAM,KAAK,IAAI,CAAC,MAAM,GAAG,EAAE;IAEjC;IAAW;aAC7B,cAAc,MAAM,CAC7B,SAAQ,KAAK,IAAI;WAGb,UAAU,OACZ,SAAQ,KAAK,IAAI;;AAKvB,KAAI,QAAQ,SAAS,EACnB,SAAQ,MAAM;AAEhB,KAAI,QAAQ,SAAS,EACnB,SAAQ,MAAM;AAGhB,QAAO;EAAE;EAAe;EAAa;EAAQ;EAAS;EAAS;;AAGjE,SAAS,SACP,UACA,UACU;AACV,KAAI,SAAS,WAAW,EACtB,QAAO,EAAE;AAEX,KAAI,SAAS,WAAW,EACtB,QAAO,SAAS,OAAO;CAGzB,MAAM,UAAU,IAAI,IAAI,SAAS;CACjC,MAAMC,UAAoB,EAAE;AAE5B,MAAK,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;EACxC,MAAM,MAAM,SAAS;AACrB,MAAI,CAAC,QAAQ,IAAI,IAAI,CACnB,SAAQ,KAAK,IAAI;;AAIrB,QAAO;;AAGT,SAAS,cACP,SACA,SACS;AACT,KAAI,QAAQ,WAAW,EACrB,QAAO;AAET,KAAI,QAAQ,WAAW,EACrB,QAAO;CAGT,MAAM,UAAU,IAAI,IAAI,QAAQ;AAChC,MAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAClC,KAAI,CAAC,QAAQ,IAAI,QAAQ,GAAG,CAC1B,QAAO;AAGX,QAAO;;;;;;AAaT,SAAgB,WACd,MACA,QACe;CACf,MAAM,OAAO,eAAe,OAAO;AAEnC,KAAI,CAAC,KACH,QAAO;EAAE;EAAQ,WAAW;EAAM,MAAM,EAAE,UAAU,OAAO;EAAE;AAG/D,KAAI,KAAK,gBAAgB,KAAK,cAC5B,QAAO;EAAE;EAAQ,WAAW;EAAM,MAAM,EAAE,UAAU,MAAM;EAAE;AAE9D,KAAI,KAAK,cAAc,KAAK,YAC1B,QAAO;EAAE;EAAQ,WAAW;EAAM,MAAM,EAAE,UAAU,MAAM;EAAE;AAG9D,KAAI,SAAS,KAAK,SAAS,KAAK,QAAQ,CAAC,SAAS,EAChD,QAAO;EAAE;EAAQ,WAAW;EAAM,MAAM,EAAE,UAAU,MAAM;EAAE;CAG9D,MAAM,0BAAU,IAAI,KAAa;CACjC,MAAM,4BAAY,IAAI,KAAwB;CAE9C,MAAM,iBAAiB,SAAS,KAAK,SAAS,KAAK,QAAQ;AAC3D,MAAK,IAAI,IAAI,GAAG,IAAI,eAAe,QAAQ,IACzC,WAAU,IAAI,eAAe,IAAI,KAAK;AAGxC,MAAK,MAAM,OAAO,OAAO,KAAK,KAAK,OAAO,EAAE;EAC1C,MAAM,YAAY,KAAK,OAAO;AAC9B,MAAI,CAAC,UACH;EAGF,MAAM,YAAY,KAAK,OAAO;AAE9B,MAAI,CAAC,WAAW;AACd,OAAI,UAAU,UAAU,SAAS,KAAK,UAAU,YAAY,GAAG;AAC7D,cAAU,IAAI,KAAK,EAAE,CAAC;AACtB,YAAQ,IAAI,IAAI;;AAElB;;AAGF,MAAI,cAAc,UAAU,WAAW,UAAU,UAAU,EAAE;AAC3D,WAAQ,IAAI,IAAI;AAChB;;AAGF,MAAI,UAAU,YAAY,UAAU,UAClC,SAAQ,IAAI,IAAI;;CAIpB,IAAI,mBAAmB;CACvB,IAAI,YAAY;AAEhB,KAAI,UAAU,OAAO,GAAG;EACtB,MAAM,QAAQ,EAAE,GAAI,QAAoC;AACxD,YAAU,SAAS,OAAO,QAAQ;AAChC,SAAM,OAAO;IACb;AACF,qBAAmB;AACnB,cAAY,eAAe,iBAAiB;;CAG9C,MAAM,eACJ,QAAQ,OAAO,IAAI,MAAM,KAAK,QAAQ,CAAC,MAAM,GAAG;AAMlD,QAAO;EACL,QAAQ;EACR;EACA,MAPW,eACT;GAAE,UAAU;GAAO;GAAc,GACjC,EAAE,UAAU,OAAO;EAMtB;;;;;ACjPH,oBAAe;;;;ACEf,IAAI,OAAO,aAAa,YACtB,KACE,MAAM,QAAQ,SAAS,mBAAmB,IAC1C,iBAAiB,cAAc,WAC/B;CACA,MAAM,QAAQ,IAAI,eAAe;AACjC,OAAM,YAAYC,cAAS;AAC3B,UAAS,qBAAqB,CAAC,GAAG,SAAS,oBAAoB,MAAM;OAChE;CACL,MAAM,UAAU,SAAS,cAAc,QAAQ;AAC/C,SAAQ,cAAcA;AACtB,UAAS,KAAK,YAAY,QAAQ;;;;;ACmCtC,MAAM,eAAe,UAAU;AAE/B,MAAaC,YAA0C,QAAQ;AAC/D,MAAaC,mBAAuD,QAAQ;AAC5E,MAAaC,qBACX,QAAQ;AAGV,sBAAe,gBAAgB;CAC7B,MAAM;CACN,cAAc;CACd,OAAO;EACL,QAAQ;EACR,OAAO,EACL,MAAM,CAAC,QAAQ,OAAO,EACvB;EACD,aAAa;EACb,eAAe;EACf,OAAO;EACP,cAAc;EACd,GAAG;EACH,GAAG;EACJ;CACD,OAAO,EAAE;CACT,OAAO;CACP,MAAM,OAAO,EAAE,OAAO,QAAQ,SAAS;EACrC,MAAM,OAAO,YAA4B;EACzC,MAAM,QAAQ,YAAyB;EACvC,MAAM,eAAe,OAAO,WAAW,KAAK;EAC5C,MAAM,qBAAqB,OAAO,kBAAkB,KAAK;EACzD,MAAM,uBAAuB,OAAO,oBAAoB,KAAK;EAE7D,MAAM,EAAE,YAAY,cAAc,SAAS,mBAAmB,OAAO,MAAM;EAE3E,MAAM,YAAY,eAAe,MAAM,SAAS,QAAQ,aAAa,CAAC;EACtE,MAAM,kBAAkB,eAChB,MAAM,eAAe,QAAQ,mBAAmB,IAAI,OAC3D;EACD,MAAM,oBAAoB,eAClB,MAAM,iBAAiB,QAAQ,qBAAqB,CAC3D;EACD,MAAM,gBAAgB,eAAe,OAAO,MAAM,CAAC;EACnD,MAAMC,kBAA2C,EAAE;EAEnD,MAAMC,4BACJ,IAAI,KAAK;EAEX,MAAM,EAAE,iBAAiB,gBAAgB,cAAc,aAAa;AAClE,OAAI,CAAC,aAAa,SAAS,MAAM,UAAU,MAAM,MAC/C,aAAY,MAAM,OAAO,MAAM,OAAO;IAExC;EAEF,IAAIC;EAEJ,SAAS,qBAAqB,MAAkC;GAC9D,MAAMC,SAAwB,EAAE;GAEhC,MAAM,gBAAgB,MAAM,gBAAgB,EAAE,EAAE,QAC7C,QAAuB,OAAO,KAChC;AACD,OAAI,aAAa,SAAS,EACxB,QAAO,eAAe,CAAC,GAAG,IAAI,IAAI,aAAa,CAAC;AAGlD,OAAI,MAAM,aAAa,OACrB,QAAO,WAAW,KAAK;AAGzB,UAAO;;EAGT,SAAS,YACP,UACA,QACA,UACA,SAAS,OACT;GACA,MAAM,UAAU,YAAY,OAAO;AAEnC,OAAI,QAAQ;AACV,aAAS,UAAU,SAAS,YAAY,EAAE,CAAC;AAC3C,oBAAgB;AAChB;;AAGF,OAAI,kBAAkB,OAAO;IAC3B,MAAMC,kBAAgB,YAAY,kBAAkB;AACpD,aAAS,UAAU,SAASA,gBAAc;AAC1C,oBAAgB;AAChB;;GAGF,MAAM,UAAU,WACd,eACA,QACD;GAED,MAAM,gBAAgB,qBAAqB,QAAQ,KAAK;AACxD,YAAS,UAAU,QAAQ,QAAQ,cAAc;AACjD,mBAAgB,QAAQ;;AAO1B,SAAO,KAAK,MAAM,CACf,QAAQ,QAAQ,KAAK,IAAI,CAAC,CAC1B,SAAS,QAAQ;AAEhB,OAAI,IAAI,QAAQ,UAAU,KAAK,GAAG;IAEhC,MAAM,YAAY,KAAK,IAAI,OAAO,EAAE,CAAC,aAAa,GAAG,IAAI,MAAM,GAAG;AAElE,oBAAgB,aAAa,MAAM;AACnC;;GAKF,IAAI,QAAQ,IAAI,OAAO,EAAE,CAAC,aAAa,GAAG,IAAI,MAAM,EAAE;GAEtD,IAAIC;AACJ,OAAI,MAAM,QAAQ,MAAM,KAAK,GAAG;AAC9B,SAAK;AACL,YAAQ,MAAM,UAAU,EAAE;;GAG5B,IAAIC;AACJ,OAAI,MAAM,UAAU,MAAM,SAAS,EAAE,KAAK,QAAQ;AAChD,WAAO;AACP,YAAQ,MAAM,UAAU,GAAG,MAAM,SAAS,EAAE;;AAG9C,aAAU,IAAI;IAAE;IAAO;IAAI;IAAM,EAAE,MAAM,KAAK;IAC9C;EAEJ,SAASC,SAAO;AACd,OAAI,CAAC,KAAK,MACR;GAGF,MAAM,WAAY,MAAM,QAAQC,KAC9B,KAAK,OACL,UAAU,OACV,gBAAgB,MACjB;AAED,OAAI,MAAM,MACR,UAAS,QAAQ,MAAM;AAGzB,aAAU,SAAS,SAAS,EAAE,IAAI,MAAM,YAAY;AAClD,QAAI,CAAC,QACH;IAGF,MAAM,SAAS,KAAK,SAAS,OAAO,GAAG;AAEvC,QAAI,MAAM;KACR,MAAM,MAAM;KACZ,IAAI,SAAS;AAEb,gBAAW,GAAG,SAAgB;AAC5B,UAAI,OACF;AAEF,eAAS;AACT,UAAI,GAAG,KAAK;AACZ,aAAO,IAAI,OAAO,QAAQ;;;AAO9B,WAAO,GAAG,OAAO,QAAQ;KACzB;GAEF,SAAS,SAAS;AAChB,QAAI,YAAY,CAAC,SAAS,YAAY,CACpC,UAAS,QAAQ;;GAIrB,SAAS,SAAS;IAChB,MAAM,EAAE,WAAW;AAEnB,QAAI,aAAa,OAAO;AACtB,SAAI,OACF,aAAY,UAAU,QAAQ,QAAW,KAAK;AAEhD;;AAGF,QAAI,OACF,aAAY,UAAU,OAAO;;AAIjC,OAAI,WAAW,MAGb,gBAAe;AACb,YAAQ;AACR,YAAQ;KACR;OAEF,SAAQ;;EAGZ,MAAMC,aACJ,QACA,UACA,eACG;AACH,OAAI,CAAC,MAAM,cAAc;AACvB,WAAK,gEAAgE;AACrE;;GAGF,MAAM,gBACJ,OAAO,aAAa,YAAY;IAAE;IAAU;IAAY,GAAG;AAE7D,OAAI,CAAC,MAAM,MACT;AAGF,eAAY,MAAM,OAAO,QAAQ,iBAAiB,QAAW,KAAK;;EAGpE,SAAS,UAAU;AACjB,OAAI,MAAM,OAAO;AACf,UAAM,MAAM,SAAS;AACrB,UAAM,QAAQ;;AAEhB,mBAAgB;;AAGlB,cACQ,MAAM,SACX,WAAW;AACV,OAAI,CAAC,QAAQ;AACX,oBAAgB;AAChB;;AAGF,OAAI,aAAa,OAAO;AACtB,WACE,oEACD;AACD;;AAGF,OAAI,CAAC,MAAM,MACT;AAGF,eAAY,MAAM,OAAO,OAAO;KAElC,EAAE,MAAM,MAAM,CACf;AAED,QACE,CAAC,cAAc,gBAAgB,QACzB;AACJ,YAAS;AACT,WAAM;KAER,EACE,MAAM,MACP,CACF;AAED,QACE,YACC,UAAU;AACT,SAAM,OAAO,SAAS,SAAS,EAAE,CAAC;KAEpC,EACE,MAAM,MACP,CACF;AAED,oBAAkB;AAChB,OAAI,MAAM,SAAS,MAAM,MACvB,OAAM,MAAM,QAAQ,MAAM;IAE5B;EAEF,MAAM,YAAY,aAAa,MAAM;AAErC,aAAW,OAAO,SAAS,eAAe;AAE1C,gBAAc,OAAO,YAAY,KAAK;AAEtC,kBAAgB;AACd,WAAM;IACN;AAEF,wBAAsB;AACpB,OAAI,gBAAgB,KAAK,MAKvB,MAAK,MAAM,YAAY;OAEvB,UAAS;IAEX;AAOF,SAAO;GAJL;GACA;GACA;GAEmB,GAAG;GAAW,CAAC;AAMpC,gBACE,EACE,UACA;GACE,GAAG,cAAc;GACjB,GAAG;GACH,KAAK;GACL,OAAO,CAAC,WAAW,cAAc,MAAM,MAAM;GAC9C,EACD,iBAAiB,CAClB;;CAEN,CAAC;;;;AC9XF,kBAAeC"}