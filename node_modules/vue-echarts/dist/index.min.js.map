{"version":3,"file":"index.min.js","names":["root","chart","autoresize","ro: ResizeObserver | null","LOADING_OPTIONS_KEY: InjectionKey<LoadingOptionsInjection>","result: Attrs","Teleport","cur: Record<string, unknown> | undefined","slotNames: SlotName[]","registered: boolean | null","arrays: Record<string, ArraySummary | undefined>","objects: string[]","scalars: string[]","missing: string[]","cssRules","THEME_KEY: InjectionKey<ThemeInjection>","INIT_OPTIONS_KEY: InjectionKey<InitOptionsInjection>","UPDATE_OPTIONS_KEY: InjectionKey<UpdateOptionsInjection>","nativeListeners: Record<string, unknown>","listeners: Map<{ event: string; once?: boolean; zr?: boolean }, any>","lastSignature: Signature | undefined","result: UpdateOptions","updateOptions","zr: boolean | undefined","once: boolean | undefined","setOption: SetOptionType","ECharts","ECharts","exported"],"sources":["../src/composables/api.ts","../src/composables/autoresize.ts","../src/composables/loading.ts","../src/utils.ts","../src/composables/slot.ts","../src/wc.ts","../src/update.ts","../src/style.css?raw","../src/style.ts","../src/ECharts.ts","../src/index.ts","../src/global.ts"],"sourcesContent":["import type { Ref } from \"vue\";\nimport type { EChartsType } from \"../types\";\n\nconst METHOD_NAMES = [\n  \"getWidth\",\n  \"getHeight\",\n  \"getDom\",\n  \"getOption\",\n  \"resize\",\n  \"dispatchAction\",\n  \"convertToPixel\",\n  \"convertFromPixel\",\n  \"containPixel\",\n  \"getDataURL\",\n  \"getConnectedDataURL\",\n  \"appendData\",\n  \"clear\",\n  \"isDisposed\",\n  \"dispose\",\n] as const;\n\ntype MethodName = (typeof METHOD_NAMES)[number];\n\nexport type PublicMethods = Pick<EChartsType, MethodName>;\n\nexport function usePublicAPI(\n  chart: Ref<EChartsType | undefined>,\n): PublicMethods {\n  function makePublicMethod<T extends MethodName>(name: T): EChartsType[T] {\n    // Return a function that matches the signature of EChartsType[T]\n    const fn = function (this: unknown, ...args: unknown[]): unknown {\n      if (!chart.value) {\n        throw new Error(\"ECharts is not initialized yet.\");\n      }\n      // Use Reflect.apply to call the method with proper context\n      return Reflect.apply(chart.value[name], chart.value, args);\n    };\n    return fn as EChartsType[T];\n  }\n\n  // Build the methods object with proper typing\n  const methods = METHOD_NAMES.reduce(\n    (acc, name) => {\n      acc[name] = makePublicMethod(name);\n      return acc;\n    },\n    {} as Record<MethodName, unknown>,\n  ) as PublicMethods;\n\n  return methods;\n}\n","import { watch } from \"vue\";\nimport { throttle } from \"echarts/core\";\n\nimport type { Ref, PropType } from \"vue\";\nimport type { EChartsType, AutoResize } from \"../types\";\n\nexport function useAutoresize(\n  chart: Ref<EChartsType | undefined>,\n  autoresize: Ref<AutoResize | undefined>,\n  root: Ref<HTMLElement | undefined>,\n): void {\n  watch(\n    [root, chart, autoresize],\n    ([root, chart, autoresize], _, onCleanup) => {\n      let ro: ResizeObserver | null = null;\n\n      if (root && chart && autoresize) {\n        const { offsetWidth, offsetHeight } = root;\n        const autoresizeOptions = autoresize === true ? {} : autoresize;\n        const { throttle: wait = 100, onResize } = autoresizeOptions;\n\n        let initialResizeTriggered = false;\n\n        const callback = () => {\n          chart.resize();\n          onResize?.();\n        };\n\n        const resizeCallback = wait ? throttle(callback, wait) : callback;\n\n        ro = new ResizeObserver(() => {\n          // We just skip ResizeObserver's initial resize callback if the\n          // size has not changed since the chart is rendered.\n          if (!initialResizeTriggered) {\n            initialResizeTriggered = true;\n            if (\n              root.offsetWidth === offsetWidth &&\n              root.offsetHeight === offsetHeight\n            ) {\n              return;\n            }\n          }\n\n          // Skip if container has zero size\n          if (root.offsetWidth === 0 || root.offsetHeight === 0) {\n            return;\n          }\n\n          resizeCallback();\n        });\n        ro.observe(root);\n      }\n\n      onCleanup(() => {\n        if (ro) {\n          ro.disconnect();\n          ro = null;\n        }\n      });\n    },\n  );\n}\n\nexport const autoresizeProps = {\n  autoresize: [Boolean, Object] as PropType<AutoResize>,\n};\n","import { inject, computed, watchEffect, toValue } from \"vue\";\n\nimport type { Ref, InjectionKey, PropType } from \"vue\";\nimport type {\n  EChartsType,\n  LoadingOptions,\n  LoadingOptionsInjection,\n} from \"../types\";\n\nexport const LOADING_OPTIONS_KEY: InjectionKey<LoadingOptionsInjection> =\n  Symbol();\n\nexport function useLoading(\n  chart: Ref<EChartsType | undefined>,\n  loading: Ref<boolean | undefined>,\n  loadingOptions: Ref<LoadingOptions | undefined>,\n): void {\n  const defaultLoadingOptions = inject(LOADING_OPTIONS_KEY, {});\n  const realLoadingOptions = computed(() => ({\n    ...toValue(defaultLoadingOptions),\n    ...loadingOptions?.value,\n  }));\n\n  watchEffect(() => {\n    const instance = chart.value;\n    if (!instance) {\n      return;\n    }\n\n    if (loading.value) {\n      instance.showLoading(realLoadingOptions.value);\n    } else {\n      instance.hideLoading();\n    }\n  });\n}\n\nexport const loadingProps = {\n  loading: Boolean,\n  loadingOptions: Object as PropType<LoadingOptions>,\n};\n","import { warn as vueWarn } from \"vue\";\n\ntype Attrs = Record<string, any>;\n\nexport function isBrowser(): boolean {\n  return typeof window !== \"undefined\" && typeof document !== \"undefined\";\n}\n\n// Copied from\n// https://github.com/vuejs/vue-next/blob/5a7a1b8293822219283d6e267496bec02234b0bc/packages/shared/src/index.ts#L40-L41\nconst onRE = /^on[^a-z]/;\nexport const isOn = (key: string): boolean => onRE.test(key);\n\nexport function omitOn(attrs: Attrs): Attrs {\n  const result: Attrs = {};\n  for (const key in attrs) {\n    if (!isOn(key)) {\n      result[key] = attrs[key];\n    }\n  }\n\n  return result;\n}\n\nexport function isValidArrayIndex(key: string): boolean {\n  const num = Number(key);\n  return (\n    Number.isInteger(num) &&\n    num >= 0 &&\n    num < Math.pow(2, 32) - 1 &&\n    String(num) === key\n  );\n}\n\nexport function isSameSet<T>(a: T[], b: T[]): boolean {\n  const setA = new Set(a);\n  const setB = new Set(b);\n\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (const val of setA) {\n    if (!setB.has(val)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isPlainObject(v: unknown): v is Record<string, unknown> {\n  return v != null && typeof v === \"object\" && !Array.isArray(v);\n}\n\nconst LOG_PREFIX = \"[vue-echarts]\";\n\nexport function warn(message: string): void {\n  vueWarn(`${LOG_PREFIX} ${message}`);\n}\n","import {\n  h,\n  Teleport,\n  onUpdated,\n  onUnmounted,\n  onMounted,\n  shallowRef,\n  shallowReactive,\n} from \"vue\";\nimport type { Slots, SlotsType } from \"vue\";\nimport type { Option } from \"../types\";\nimport { isBrowser, isValidArrayIndex, isSameSet, warn } from \"../utils\";\nimport type { TooltipComponentFormatterCallbackParams } from \"echarts\";\n\nconst SLOT_OPTION_PATHS = {\n  tooltip: [\"tooltip\", \"formatter\"],\n  dataView: [\"toolbox\", \"feature\", \"dataView\", \"optionToContent\"],\n} as const;\ntype SlotPrefix = keyof typeof SLOT_OPTION_PATHS;\ntype SlotName = SlotPrefix | `${SlotPrefix}-${string}`;\ntype SlotRecord<T> = Partial<Record<SlotName, T>>;\nconst SLOT_PREFIXES = Object.keys(SLOT_OPTION_PATHS) as SlotPrefix[];\n\nfunction isValidSlotName(key: string): key is SlotName {\n  return SLOT_PREFIXES.some(\n    (slotPrefix) => key === slotPrefix || key.startsWith(slotPrefix + \"-\"),\n  );\n}\n\nexport function useSlotOption(slots: Slots, onSlotsChange: () => void) {\n  const detachedRoot = isBrowser() ? document.createElement(\"div\") : undefined;\n  const containers = shallowReactive<SlotRecord<HTMLElement>>({});\n  const initialized = shallowReactive<SlotRecord<boolean>>({});\n  const params = shallowReactive<SlotRecord<unknown>>({});\n  const isMounted = shallowRef(false);\n\n  // Teleport the slots to a detached root\n  const teleportedSlots = () => {\n    // Make slots client-side only to avoid SSR hydration mismatch\n    return isMounted.value && detachedRoot\n      ? h(\n          Teleport,\n          { to: detachedRoot },\n          Object.entries(slots)\n            .filter(([key]) => isValidSlotName(key))\n            .map(([key, slot]) => {\n              const slotName = key as SlotName;\n              const slotContent = initialized[slotName]\n                ? slot?.(params[slotName])\n                : undefined;\n              return h(\n                \"div\",\n                {\n                  ref: (el) => {\n                    if (el instanceof HTMLElement) {\n                      containers[slotName] = el;\n                    }\n                  },\n                  style: { display: \"contents\" },\n                },\n                slotContent,\n              );\n            }),\n        )\n      : undefined;\n  };\n\n  // Helper to check if a value is a plain object\n  function isObject(val: unknown): val is Record<string, unknown> {\n    return val !== null && typeof val === \"object\" && !Array.isArray(val);\n  }\n\n  // Shallow-clone the option along each path and override the target callback\n  function patchOption(src: Option): Option {\n    const root = { ...src } as Record<string, unknown>;\n\n    // Ensure the child at `seg` is a writable container (cloned or newly created).\n    // Returns the child container, or undefined if traversal is blocked by a primitive.\n    const ensureChild = (\n      parent: Record<string, unknown>,\n      seg: string,\n    ): Record<string, unknown> | undefined => {\n      const next = parent[seg];\n\n      if (Array.isArray(next)) {\n        parent[seg] = [...next];\n        return parent[seg] as Record<string, unknown>;\n      }\n      if (isObject(next)) {\n        parent[seg] = { ...next };\n        return parent[seg] as Record<string, unknown>;\n      }\n      if (next === undefined) {\n        parent[seg] = isValidArrayIndex(seg) ? [] : {};\n        return parent[seg] as Record<string, unknown>;\n      }\n      // Blocked by a non-container value\n      return undefined;\n    };\n\n    Object.keys(slots)\n      .filter((key) => {\n        const valid = isValidSlotName(key);\n        if (!valid) {\n          warn(`Invalid slot name: ${key}`);\n        }\n        return valid;\n      })\n      .forEach((key) => {\n        const [prefix, ...rest] = key.split(\"-\") as [SlotPrefix, ...string[]];\n        const tail = SLOT_OPTION_PATHS[prefix];\n        if (!tail) {\n          return;\n        }\n\n        const path = [...rest, ...tail];\n        if (path.length === 0) {\n          return;\n        }\n\n        // Traverse to the parent of the leaf, cloning or creating along the way\n        let cur: Record<string, unknown> | undefined = root;\n        for (let i = 0; i < path.length - 1; i++) {\n          cur = ensureChild(cur, path[i]);\n          if (!cur) {\n            return; // Blocked by a primitive â€” skip this key\n          }\n        }\n\n        cur[path[path.length - 1]] = (p: unknown) => {\n          initialized[key] = true;\n          params[key] = p;\n          return containers[key];\n        };\n      });\n\n    return root as Option;\n  }\n\n  // `slots` is not reactive, so we need to watch it manually\n  let slotNames: SlotName[] = [];\n  onUpdated(() => {\n    const newSlotNames = Object.keys(slots).filter(isValidSlotName);\n    if (!isSameSet(newSlotNames, slotNames)) {\n      // Clean up states for removed slots\n      slotNames.forEach((key) => {\n        if (!newSlotNames.includes(key)) {\n          delete params[key];\n          delete initialized[key];\n          delete containers[key];\n        }\n      });\n      slotNames = newSlotNames;\n      onSlotsChange();\n    }\n  });\n\n  onMounted(() => {\n    isMounted.value = true;\n  });\n\n  onUnmounted(() => {\n    detachedRoot?.remove();\n  });\n\n  return {\n    teleportedSlots,\n    patchOption,\n  };\n}\n\nexport type SlotsTypes = SlotsType<\n  Record<\n    \"tooltip\" | `tooltip-${string}`,\n    TooltipComponentFormatterCallbackParams\n  > &\n    Record<\"dataView\" | `dataView-${string}`, Option>\n>;\n","import { isBrowser } from \"./utils\";\n\nlet registered: boolean | null = null;\n\nexport const TAG_NAME = \"x-vue-echarts\";\n\nexport interface EChartsElement extends HTMLElement {\n  __dispose: (() => void) | null;\n}\n\nexport function register(): boolean {\n  if (registered != null) {\n    return registered;\n  }\n\n  const registry = globalThis.customElements;\n\n  if (!isBrowser() || !registry?.get) {\n    registered = false;\n    return registered;\n  }\n\n  if (!registry.get(TAG_NAME)) {\n    try {\n      class ECElement extends HTMLElement implements EChartsElement {\n        __dispose: (() => void) | null = null;\n\n        disconnectedCallback(): void {\n          if (this.__dispose) {\n            this.__dispose();\n            this.__dispose = null;\n          }\n        }\n      }\n\n      registry.define(TAG_NAME, ECElement);\n    } catch {\n      registered = false;\n      return registered;\n    }\n  }\n\n  registered = true;\n  return registered;\n}\n","import type { Option } from \"./types\";\nimport { isPlainObject } from \"./utils\";\n\nexport interface UpdatePlan {\n  notMerge: boolean;\n  replaceMerge?: string[];\n}\n\n/** Summary of a top-level array key for deletion detection. */\nexport interface ArraySummary {\n  /** Unique, sorted string ids extracted from items' `id` field. */\n  idsSorted: string[];\n  /** Count of items without an `id` field. */\n  noIdCount: number;\n}\n\n/** Minimal signature of an option used to decide setOption behavior. */\nexport interface Signature {\n  /** Lengths of `option.options` and `option.media` (0 if not arrays). */\n  optionsLength: number;\n  mediaLength: number;\n  /** Map of array-typed top-level keys to their summaries. */\n  arrays: Record<string, ArraySummary | undefined>;\n  /** Sorted list of object-typed top-level keys. */\n  objects: string[];\n  /** Sorted list of scalar-typed top-level keys (string|number|boolean|null). */\n  scalars: string[];\n}\n\n/**\n * Read an item's `id` as a string.\n * Only accept string or number. Other types are ignored to surface inconsistent data early.\n */\nfunction readId(item: unknown): string | undefined {\n  if (!isPlainObject(item)) {\n    return undefined;\n  }\n  const raw = (item as { id?: unknown }).id;\n  if (typeof raw === \"string\") {\n    return raw;\n  }\n  if (typeof raw === \"number\" && Number.isFinite(raw)) {\n    return String(raw);\n  }\n  return undefined;\n}\n\n/**\n * Build a minimal signature from a full ECharts option.\n * Only top-level keys are inspected.\n */\nexport function buildSignature(option: Option): Signature {\n  const opt = option as Record<string, unknown>;\n\n  const optionsLength = Array.isArray(opt.options)\n    ? (opt.options as unknown[]).length\n    : 0;\n  const mediaLength = Array.isArray(opt.media)\n    ? (opt.media as unknown[]).length\n    : 0;\n\n  const arrays: Record<string, ArraySummary | undefined> = Object.create(null);\n  const objects: string[] = [];\n  const scalars: string[] = [];\n\n  for (const key of Object.keys(opt)) {\n    if (key === \"options\" || key === \"media\") {\n      continue;\n    }\n\n    const value = opt[key];\n\n    if (Array.isArray(value)) {\n      const items = value as unknown[];\n      const ids = new Set<string>();\n      let noIdCount = 0;\n\n      for (let i = 0; i < items.length; i++) {\n        const id = readId(items[i]);\n        if (id !== undefined) {\n          ids.add(id);\n        } else {\n          noIdCount++;\n        }\n      }\n\n      const idsSorted = ids.size > 0 ? Array.from(ids).sort() : [];\n\n      arrays[key] = { idsSorted, noIdCount };\n    } else if (isPlainObject(value)) {\n      objects.push(key);\n    } else {\n      // scalar: string | number | boolean | null  (undefined is treated as \"absent\")\n      if (value !== undefined) {\n        scalars.push(key);\n      }\n    }\n  }\n\n  if (objects.length > 1) {\n    objects.sort();\n  }\n  if (scalars.length > 1) {\n    scalars.sort();\n  }\n\n  return { optionsLength, mediaLength, arrays, objects, scalars };\n}\n\nfunction diffKeys(\n  prevKeys: readonly string[],\n  nextKeys: readonly string[],\n): string[] {\n  if (prevKeys.length === 0) {\n    return [];\n  }\n  if (nextKeys.length === 0) {\n    return prevKeys.slice();\n  }\n\n  const nextSet = new Set(nextKeys);\n  const missing: string[] = [];\n\n  for (let i = 0; i < prevKeys.length; i++) {\n    const key = prevKeys[i];\n    if (!nextSet.has(key)) {\n      missing.push(key);\n    }\n  }\n\n  return missing;\n}\n\nfunction hasMissingIds(\n  prevIds: readonly string[],\n  nextIds: readonly string[],\n): boolean {\n  if (prevIds.length === 0) {\n    return false;\n  }\n  if (nextIds.length === 0) {\n    return true;\n  }\n\n  const nextSet = new Set(nextIds);\n  for (let i = 0; i < prevIds.length; i++) {\n    if (!nextSet.has(prevIds[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface PlannedUpdate {\n  option: Option;\n  signature: Signature;\n  plan: UpdatePlan;\n}\n\n/**\n * Produce an update plan plus a normalized option that encodes common deletions.\n * Falls back to `notMerge: true` when the change looks complex.\n */\nexport function planUpdate(\n  prev: Signature | undefined,\n  option: Option,\n): PlannedUpdate {\n  const next = buildSignature(option);\n\n  if (!prev) {\n    return { option, signature: next, plan: { notMerge: false } };\n  }\n\n  if (next.optionsLength < prev.optionsLength) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n  if (next.mediaLength < prev.mediaLength) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n\n  if (diffKeys(prev.scalars, next.scalars).length > 0) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n\n  const replace = new Set<string>();\n  const overrides = new Map<string, null | []>();\n\n  const missingObjects = diffKeys(prev.objects, next.objects);\n  for (let i = 0; i < missingObjects.length; i++) {\n    overrides.set(missingObjects[i], null);\n  }\n\n  for (const key of Object.keys(prev.arrays)) {\n    const prevArray = prev.arrays[key];\n    if (!prevArray) {\n      continue;\n    }\n\n    const nextArray = next.arrays[key];\n\n    if (!nextArray) {\n      if (prevArray.idsSorted.length > 0 || prevArray.noIdCount > 0) {\n        overrides.set(key, []);\n        replace.add(key);\n      }\n      continue;\n    }\n\n    if (hasMissingIds(prevArray.idsSorted, nextArray.idsSorted)) {\n      replace.add(key);\n      continue;\n    }\n\n    if (nextArray.noIdCount < prevArray.noIdCount) {\n      replace.add(key);\n    }\n  }\n\n  let normalizedOption = option;\n  let signature = next;\n\n  if (overrides.size > 0) {\n    const clone = { ...(option as Record<string, unknown>) };\n    overrides.forEach((value, key) => {\n      clone[key] = value;\n    });\n    normalizedOption = clone as Option;\n    signature = buildSignature(normalizedOption);\n  }\n\n  const replaceMerge =\n    replace.size > 0 ? Array.from(replace).sort() : undefined;\n\n  const plan = replaceMerge\n    ? { notMerge: false, replaceMerge }\n    : { notMerge: false };\n\n  return {\n    option: normalizedOption,\n    signature,\n    plan,\n  };\n}\n","export default \"x-vue-echarts{display:block;width:100%;height:100%;min-width:0;}\\nx-vue-echarts>:first-child,x-vue-echarts>:first-child>canvas{border-radius:inherit;}\\n\"","import cssRules from \"./style.css?raw\";\n\nif (typeof document !== \"undefined\") {\n  if (\n    Array.isArray(document.adoptedStyleSheets) &&\n    \"replaceSync\" in CSSStyleSheet.prototype\n  ) {\n    const sheet = new CSSStyleSheet();\n    sheet.replaceSync(cssRules);\n    document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];\n  } else {\n    const styleEl = document.createElement(\"style\");\n    styleEl.textContent = cssRules;\n    document.head.appendChild(styleEl);\n  }\n}\n","import {\n  defineComponent,\n  shallowRef,\n  toRefs,\n  watch,\n  computed,\n  inject,\n  onMounted,\n  onBeforeUnmount,\n  h,\n  nextTick,\n  watchEffect,\n  toValue,\n} from \"vue\";\nimport { init as initChart } from \"echarts/core\";\nimport type { EChartsOption } from \"echarts\";\n\nimport {\n  usePublicAPI,\n  useAutoresize,\n  autoresizeProps,\n  useLoading,\n  loadingProps,\n  useSlotOption,\n} from \"./composables\";\nimport type { PublicMethods, SlotsTypes } from \"./composables\";\nimport { isOn, omitOn, warn } from \"./utils\";\nimport { register, TAG_NAME } from \"./wc\";\nimport { planUpdate } from \"./update\";\nimport type { Signature, UpdatePlan } from \"./update\";\n\nimport type { PropType, InjectionKey } from \"vue\";\nimport type {\n  EChartsType,\n  SetOptionType,\n  Option,\n  Theme,\n  ThemeInjection,\n  InitOptions,\n  InitOptionsInjection,\n  UpdateOptions,\n  UpdateOptionsInjection,\n  Emits,\n} from \"./types\";\nimport type { EChartsElement } from \"./wc\";\n\nimport \"./style.ts\";\n\nconst wcRegistered = register();\n\nexport const THEME_KEY: InjectionKey<ThemeInjection> = Symbol();\nexport const INIT_OPTIONS_KEY: InjectionKey<InitOptionsInjection> = Symbol();\nexport const UPDATE_OPTIONS_KEY: InjectionKey<UpdateOptionsInjection> =\n  Symbol();\nexport { LOADING_OPTIONS_KEY } from \"./composables\";\n\nexport default defineComponent({\n  name: \"Echarts\",\n  inheritAttrs: false,\n  props: {\n    option: Object as PropType<Option>,\n    theme: {\n      type: [Object, String] as PropType<Theme>,\n    },\n    initOptions: Object as PropType<InitOptions>,\n    updateOptions: Object as PropType<UpdateOptions>,\n    group: String,\n    manualUpdate: Boolean,\n    ...autoresizeProps,\n    ...loadingProps,\n  },\n  emits: {} as unknown as Emits,\n  slots: Object as SlotsTypes,\n  setup(props, { attrs, expose, slots }) {\n    const root = shallowRef<EChartsElement>();\n    const chart = shallowRef<EChartsType>();\n    const defaultTheme = inject(THEME_KEY, null);\n    const defaultInitOptions = inject(INIT_OPTIONS_KEY, null);\n    const defaultUpdateOptions = inject(UPDATE_OPTIONS_KEY, null);\n\n    const { autoresize, manualUpdate, loading, loadingOptions } = toRefs(props);\n\n    const realTheme = computed(() => props.theme || toValue(defaultTheme));\n    const realInitOptions = computed(\n      () => props.initOptions || toValue(defaultInitOptions) || undefined,\n    );\n    const realUpdateOptions = computed(\n      () => props.updateOptions || toValue(defaultUpdateOptions),\n    );\n    const nonEventAttrs = computed(() => omitOn(attrs));\n    const nativeListeners: Record<string, unknown> = {};\n\n    const listeners: Map<{ event: string; once?: boolean; zr?: boolean }, any> =\n      new Map();\n\n    const { teleportedSlots, patchOption } = useSlotOption(slots, () => {\n      if (!manualUpdate.value && props.option && chart.value) {\n        applyOption(chart.value, props.option);\n      }\n    });\n\n    let lastSignature: Signature | undefined;\n\n    function resolveUpdateOptions(plan?: UpdatePlan): UpdateOptions {\n      const result: UpdateOptions = {};\n\n      const replacements = (plan?.replaceMerge ?? []).filter(\n        (key): key is string => key != null,\n      );\n      if (replacements.length > 0) {\n        result.replaceMerge = [...new Set(replacements)];\n      }\n\n      if (plan?.notMerge !== undefined) {\n        result.notMerge = plan.notMerge;\n      }\n\n      return result;\n    }\n\n    function applyOption(\n      instance: EChartsType,\n      option: Option,\n      override?: UpdateOptions,\n      manual = false,\n    ) {\n      const patched = patchOption(option);\n\n      if (manual) {\n        instance.setOption(patched, override ?? {});\n        lastSignature = undefined;\n        return;\n      }\n\n      if (realUpdateOptions.value) {\n        const updateOptions = override ?? realUpdateOptions.value;\n        instance.setOption(patched, updateOptions);\n        lastSignature = undefined;\n        return;\n      }\n\n      const planned = planUpdate(\n        lastSignature,\n        patched as unknown as EChartsOption,\n      );\n\n      const updateOptions = resolveUpdateOptions(planned.plan);\n      instance.setOption(planned.option, updateOptions);\n      lastSignature = planned.signature;\n    }\n\n    // We are converting all `on<Event>` props and collect them into `listeners` so that\n    // we can bind them to the chart instance later.\n    // For `onNative:<event>` props, we just strip the `Native:` part and collect them into\n    // `nativeListeners` so that we can bind them to the root element directly.\n    Object.keys(attrs)\n      .filter((key) => isOn(key))\n      .forEach((key) => {\n        // Collect native DOM events\n        if (key.indexOf(\"Native:\") === 2) {\n          // onNative:click -> onClick\n          const nativeKey = `on${key.charAt(9).toUpperCase()}${key.slice(10)}`;\n\n          nativeListeners[nativeKey] = attrs[key];\n          return;\n        }\n\n        // onClick    -> c + lick\n        // onZr:click -> z + r:click\n        let event = key.charAt(2).toLowerCase() + key.slice(3);\n\n        let zr: boolean | undefined;\n        if (event.indexOf(\"zr:\") === 0) {\n          zr = true;\n          event = event.substring(3);\n        }\n\n        let once: boolean | undefined;\n        if (event.substring(event.length - 4) === \"Once\") {\n          once = true;\n          event = event.substring(0, event.length - 4);\n        }\n\n        listeners.set({ event, zr, once }, attrs[key]);\n      });\n\n    function init() {\n      if (!root.value) {\n        return;\n      }\n\n      const instance = (chart.value = initChart(\n        root.value,\n        realTheme.value,\n        realInitOptions.value,\n      ));\n\n      if (props.group) {\n        instance.group = props.group;\n      }\n\n      listeners.forEach((handler, { zr, once, event }) => {\n        if (!handler) {\n          return;\n        }\n\n        const target = zr ? instance.getZr() : instance;\n\n        if (once) {\n          const raw = handler;\n          let called = false;\n\n          handler = (...args: any[]) => {\n            if (called) {\n              return;\n            }\n            called = true;\n            raw(...args);\n            target.off(event, handler);\n          };\n        }\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore EChartsType[\"on\"] is not compatible with ZRenderType[\"on\"]\n        // but it's okay here\n        target.on(event, handler);\n      });\n\n      function resize() {\n        if (instance && !instance.isDisposed()) {\n          instance.resize();\n        }\n      }\n\n      function commit() {\n        const { option } = props;\n\n        if (manualUpdate.value) {\n          if (option) {\n            applyOption(instance, option, undefined, true);\n          }\n          return;\n        }\n\n        if (option) {\n          applyOption(instance, option);\n        }\n      }\n\n      if (autoresize.value) {\n        // Try to make chart fit to container in case container size\n        // is changed synchronously or in already queued microtasks\n        nextTick(() => {\n          resize();\n          commit();\n        });\n      } else {\n        commit();\n      }\n    }\n    const setOption: SetOptionType = (\n      option,\n      notMerge,\n      lazyUpdate?: boolean,\n    ) => {\n      if (!props.manualUpdate) {\n        warn(\"`setOption` is only available when `manual-update` is `true`.\");\n        return;\n      }\n\n      const updateOptions =\n        typeof notMerge === \"boolean\" ? { notMerge, lazyUpdate } : notMerge;\n\n      if (!chart.value) {\n        return;\n      }\n\n      applyOption(chart.value, option, updateOptions ?? undefined, true);\n    };\n\n    function cleanup() {\n      if (chart.value) {\n        chart.value.dispose();\n        chart.value = undefined;\n      }\n      lastSignature = undefined;\n    }\n\n    watch(\n      () => props.option,\n      (option) => {\n        if (!option) {\n          lastSignature = undefined;\n          return;\n        }\n\n        if (manualUpdate.value) {\n          warn(\n            \"`option` prop changes are ignored when `manual-update` is `true`.\",\n          );\n          return;\n        }\n\n        if (!chart.value) {\n          return;\n        }\n\n        applyOption(chart.value, option);\n      },\n      { deep: true },\n    );\n\n    watch(\n      [manualUpdate, realInitOptions],\n      () => {\n        cleanup();\n        init();\n      },\n      {\n        deep: true,\n      },\n    );\n\n    watch(\n      realTheme,\n      (theme) => {\n        chart.value?.setTheme(theme || {});\n      },\n      {\n        deep: true,\n      },\n    );\n\n    watchEffect(() => {\n      if (props.group && chart.value) {\n        chart.value.group = props.group;\n      }\n    });\n\n    const publicApi = usePublicAPI(chart);\n\n    useLoading(chart, loading, loadingOptions);\n\n    useAutoresize(chart, autoresize, root);\n\n    onMounted(() => {\n      init();\n    });\n\n    onBeforeUnmount(() => {\n      if (wcRegistered && root.value) {\n        // For registered web component, we can leverage the\n        // `disconnectedCallback` to dispose the chart instance\n        // so that we can delay the cleanup after exsiting leaving\n        // transition.\n        root.value.__dispose = cleanup;\n      } else {\n        cleanup();\n      }\n    });\n\n    const exposed = {\n      setOption,\n      root,\n      chart,\n    };\n    expose({ ...exposed, ...publicApi });\n\n    // While `expose()` exposes methods and properties to the parent component\n    // via template refs at runtime, it doesn't contribute to TypeScript types.\n    // This type casting ensures TypeScript correctly types the exposed members\n    // that will be available when using this component.\n    return (() =>\n      h(\n        TAG_NAME,\n        {\n          ...nonEventAttrs.value,\n          ...nativeListeners,\n          ref: root,\n          class: [\"echarts\", nonEventAttrs.value.class],\n        },\n        teleportedSlots(),\n      )) as unknown as typeof exposed & PublicMethods;\n  },\n});\n","import ECharts from \"./ECharts\";\n\nexport default ECharts;\nexport * from \"./ECharts\";\n","import \"echarts\";\nimport ECharts, * as exported from \"./index\";\n\nexport default {\n  ...ECharts,\n  ...exported,\n};\n"],"mappings":"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"}